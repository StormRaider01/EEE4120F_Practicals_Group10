% =========================================================================
% Practical 2: Mandelbrot-Set Serial vs Parallel Analysis
% =========================================================================
%
% GROUP NUMBER: 10
%
% MEMBERS:
%   - Member 1 Maarij Alam, ALMMOH017
%   - Member 2 Saeed Solomon, SLMMOG032

%% ========================================================================
%  PART 4: Testing and Analysis
%  ========================================================================
% Compare the performance of serial Mandelbrot set computation
% with parallel Mandelbrot set computation.

function run_analysis()
    %Array conatining all the image sizes to be tested
    image_sizes = [
        [800,600],   %SVGA
        [1280,720],  %HD
        [1920,1080], %Full HD
        [2048,1080], %2K Cinema
        [2560,1440], %2K QHD
        [3840,2160], %4K UHD
        [5120,2880], %5K
        [7680,4320]  %8K UHD
    ];

    max_iterations = 1000; 

    % Initialize arrays to store results
    results = zeros(length(image_sizes), 4); % Columns: [image size, time_serial, time_parallel, speedup]
    
    %TODO: For each image size, perform the following:
    for counter = 1:length(image_sizes)
        width = image_sizes(counter, 1);
        height = image_sizes(counter, 2);

        results(counter, 1) = printf('%d x %d', width, height);

        %   a. Measure execution time of mandelbrot_serial
        tic;
        searial_output = mandelbrot_serial(width, height, max_iterations);
        results(counter, 2) = toc;


        %   b. Measure execution time of mandelbrot_parallel
        tic;
        
        parallel_output = mandelbrot_parallel(width, height, max_iterations);
        results(counter, 3) = toc;
        
        %   c. Store results (image size, time_serial, time_parallel, speedup) 
        results(counter, 4) = results(counter, 2) / results(counter, 3);

        %   d. Plot and save the Mandelbrot set images generated by both methods
        mandelbrot_plot(searial_output, parallel_output, width, height); 
    end
    
end

%% ========================================================================
%  PART 1: Mandelbrot Set Image Plotting and Saving
%  ========================================================================
%
% TODO: Implement Mandelbrot set plotting and saving function
function mandelbrot_plot(varargin) %Add necessary input arguments
    
end

%% ========================================================================
%  PART 2: Serial Mandelbrot Set Computation
%  ========================================================================`
%
%TODO: Implement serial Mandelbrot set computation function
function iteration_counts = mandelbrot_serial(width, height, max_iterations) %Add necessary input arguments 
    
    iteration_counts = zeros(height, width);
    
    for xp = 1:width
        for py = 1:height
            x0 = (xp/width)*2.5 - 2.0;
            y0 = (py/height) * 2.4 -1.2;
            x = 0; y = 0; 
            
            iteration = 0; %making this a temp variable to speed up more
    
            while (iteration < max_iterations) && (x^2 + y^2 <= 4)
                x_next = x^2 - y^2 + x0;
                y_next = 2*x*y + y0;
                x = x_next;
                y = y_next;
                iteration = iteration + 1;
            end
    
            iteration_counts(py, xp) = iteration;
        end
    end

end

%% ========================================================================
%  PART 3: Parallel Mandelbrot Set Computation
%  ========================================================================
%
%TODO: Implement parallel Mandelbrot set computation function
function iteration_counts =mandelbrot_parallel(width, height, max_iterations, num_workers) %Add necessary input arguments

        
        %code to initialise the parallelism with the workers
        if(isempty(gcp('nocreate')))
           c = parcluster;
           p = c.parpool(num_workers); %change num_workers param to get more workers
        end

        iteration_counts = zeros(height, width); 

        parfor xp = 1:width
            %to fix sliced variable conflict:
            column = zeros(height, 1);
            for py = 1:height
                x0 = (xp/width)*2.5 - 2.0;
                y0 = (py/height) * 2.4 -1.2;
                x = 0; y = 0; 
                iteration = 0; %making this a temp variable to speed up more
    
                while (iteration < max_iterations) && (x^2 + y^2 <= 4)
                    x_next = x^2 - y^2 + x0;
                    y_next = 2*x*y + y0;
                    x = x_next;
                    y = y_next;
                    iteration = iteration + 1;
                end
                column(py) = iteration;
                
            end
            iteration_counts(:, xp) = column;
        end

end